## Chosen Approach
Implement integration tests using a dedicated `ChromeRuntimeHarness` utility to precisely simulate Chrome's runtime messaging environment, enabling the actual service worker and content script modules to communicate as they would in a browser, with only the `chrome.*` APIs and other true external dependencies (e.g., `fetch`, `chrome.storage.*`) being mocked.

## Rationale
-   **Simplicity (in tests):** The `ChromeRuntimeHarness` abstracts complex mocking logic, making individual test cases clean, focused on specific communication scenarios, and easier to write and understand.
-   **Modularity + strict separation:** The harness is a distinct, reusable module responsible for mocking the *external* Chrome environment. This cleanly separates test infrastructure from the application logic being tested, ensuring internal application modules are not mocked.
-   **Testability (minimal mocking):** The harness acts as the controlled mock specifically for `chrome.*` APIs. The service worker and content script code run as-is, directly fulfilling the "NO Mocking Internal Collaborators" and "Mock ONLY True External System Boundaries" principles.
-   **Coding Standards:** Promotes a clear and maintainable test structure, with well-defined interfaces for interacting with the mocked Chrome environment.
-   **Documentation Approach:** The harness design and the test cases themselves serve as executable documentation for the expected messaging interactions and Chrome API usage.

## Build Steps

### 1. Test Architecture Design

1.1. **Overall Structure:**
    -   Tests will execute in a Node.js environment managed by Vitest.
    -   A central `ChromeRuntimeHarness` class will be developed. This harness is responsible for simulating the Chrome extension messaging environment.
    -   The harness will provide mock implementations for `chrome.runtime.sendMessage`, `chrome.runtime.onMessage.addListener`, `chrome.runtime.onMessage.removeListener`, and manage `chrome.runtime.lastError`. It can be extended to mock `chrome.tabs.sendMessage` or other relevant `chrome.*` APIs if the application uses them for SW-CS communication.
    -   The actual service worker module (`src/service-worker/index.ts`) and the content script messaging module (`src/content-script/messaging.ts`) will be dynamically imported and initialized within the test environment. Their internal logic, including calls to other internal application modules, will **not** be mocked.

1.2. **Modules to Test:**
    -   **Primary Targets:** The message handling logic within `src/service-worker/index.ts` and the message sending/receiving logic within `src/content-script/messaging.ts`.
    -   **Indirectly Tested:** Any internal modules these primary modules collaborate with (e.g., caching utilities, API client wrappers within the service worker) will be exercised as part of the integration test, as they are not mocked.

1.3. **Test Organization and File Structure:**
    -   Integration tests will reside in a dedicated directory: `tests/integration/`.
    -   Main test file: `tests/integration/messaging.integration.test.ts`.
    -   Harness implementation: `tests/harness/ChromeRuntimeHarness.ts`.
    -   Shared test utilities or specific mocks (e.g., for `fetch` or `chrome.storage.local`): `tests/utils/` or `tests/mocks/`.

1.4. **Mock Strategy for Chrome APIs (via Harness):**
    -   The `ChromeRuntimeHarness` will maintain internal state for registered `onMessage` listeners from both service worker and content script contexts.
    -   **`chrome.runtime.onMessage.addListener(callback)`:** The harness's mock will capture the `callback` and associate it with the context (Service Worker or Content Script) that registered it.
    -   **`chrome.runtime.sendMessage(message, responseCallback?)`:**
        -   The harness's mock intercepts the `message`.
        -   It determines the intended recipient context (e.g., if CS sends, target is SW; if SW sends, target is CS).
        -   It invokes the stored listener(s) of the target context with `(message, sender, sendResponseFn)`.
        -   The `sender` argument will be a mock object (e.g., `{ id: 'extension-id', tab?: { id: 123 } }`) constructed by the harness.
        -   The `sendResponseFn` is a function generated by the harness. When called by the message listener:
            -   If a `responseCallback` was provided to the original `sendMessage` call, this `responseCallback` is invoked with the arguments from `sendResponseFn`.
            -   It must correctly handle the `return true;` convention for asynchronous responses, ensuring `sendResponseFn` can be called later and will still trigger the original `responseCallback`.
            -   It will manage `chrome.runtime.lastError`, setting or clearing it based on the outcome of the message handling or `sendResponse` call.
    -   **Truly External Dependencies:** Other external dependencies like `global.fetch` (for API calls) or `chrome.storage.local` (if used for caching directly by the SW/CS and not through an internal module that *could* be tested separately) will be mocked using Vitest's standard mocking utilities (e.g., `vi.spyOn(global, 'fetch')`, `vi.mock('chrome', ...)` for storage if not part of the harness).

### 2. Test Coverage Strategy

2.1. **Key Scenarios to Test:**
    -   **Content Script to Service Worker Request/Response:** CS sends a message (e.g., `GET_BITCOIN_PRICE`), SW processes (interacting with mock cache/API), SW sends a response, CS receives the correct response.
    -   **Service Worker to Content Script Push (if applicable):** SW proactively sends a message (e.g., `PRICE_UPDATED_EVENT`), CS receives and processes.
    -   **Multiple Sequential Messages:** Ensure correct handling of a series of messages and responses.
    -   **Message Types:** Cover all defined message types from `src/common/types.ts`.

2.2. **Happy Path Tests:**
    -   **Cache Hit:** CS requests data; SW has it in its (mocked) cache; SW responds from cache.
    -   **Cache Miss, API Success:** CS requests data; SW cache miss; SW calls (mocked) API which returns success; SW updates (mocked) cache; SW responds with API data.
    -   **Successful SW to CS Push:** SW sends an update; CS listener is triggered with correct data.

2.3. **Error Cases and Edge Cases:**
    -   **API Failure:** CS requests data; SW cache miss; SW calls (mocked) API which returns an error; SW responds with an error message or appropriate default.
    -   **Invalid Message Format from CS/SW:** One context sends a malformed/unexpected message; the other handles it gracefully (e.g., ignores, logs, or sends an error response).
    -   **No Listener in Target Context:** Message sent, but no listener registered for that message type or in the target context. Verify `responseCallback` behavior and `chrome.runtime.lastError`.
    -   **`sendResponse` Not Called:** Listener receives a message but doesn't call `sendResponse`. Verify `responseCallback` behavior (e.g., called with `undefined`, or potential timeout behavior if Chrome enforces it).
    -   **`sendResponse` Called Late (after listener returns non-true):** Verify behavior of the `responseCallback`.
    -   **`chrome.runtime.lastError` Propagation:** Ensure errors during `sendMessage` (e.g., no receiving end) or within `sendResponse` are correctly propagated to `chrome.runtime.lastError` and can be checked by the sender.
    -   **Message Validation Failures:** If messages are validated against types from `src/common/types.ts`, test scenarios with invalid payloads.

2.4. **Bidirectional Communication Tests:**
    -   Scenarios where CS initiates, SW responds, and subsequently, the SW might initiate a new, separate message back to the CS based on some internal logic or event.

### 3. Implementation Details

3.1. **Test Environment Setup:**
    -   Standard Vitest configuration (`vitest.config.ts`).
    -   A global setup file for Vitest (`tests/setup.ts`) or `beforeEach` blocks in `messaging.integration.test.ts` will be used to:
        -   Instantiate `ChromeRuntimeHarness`.
        -   Use `vi.stubGlobal('chrome', harnessInstance.getMockChromeApi())` to replace the global `chrome` object with the harness's mock.
        -   Dynamically import and initialize the service worker (`src/service-worker/index.ts`) and content script (`src/content-script/messaging.ts`) modules. This ensures their `onMessage.addListener` calls are routed to the harness. The harness might need methods like `harness.loadServiceWorkerContext(() => import(...))` to correctly associate listeners.

3.2. **Mocking Chrome Runtime APIs (Core of `ChromeRuntimeHarness`):**
    -   The `ChromeRuntimeHarness` class will internally manage lists of listeners for SW and CS.
    -   `getMockChromeApi()`: Returns an object shaped like the `chrome` API, with `runtime.onMessage`, `runtime.sendMessage`, etc., pointing to the harness's methods.
    -   `onMessageAddListener(listener)`: Adds the listener to the appropriate list based on the current "context" during initialization (or a parameter).
    -   `sendMessage(message, responseCallback)`:
        -   Identifies the source and target (e.g., CS to SW).
        -   Iterates through the target's listeners.
        -   For each listener, calls it with `(message, senderDetails, harnessSendResponse)`.
        -   `harnessSendResponse` is a special function that, when called by the listener, will invoke the original `responseCallback` passed to `sendMessage`. It needs to handle the `return true` asynchronous pattern.
        -   Manages `chrome.runtime.lastError`.

3.3. **How to Simulate Message Passing:**
    -   **CS to SW:**
        1.  Test calls a function from the imported `src/content-script/messaging.ts` that internally calls `chrome.runtime.sendMessage`.
        2.  The harness's `sendMessage` mock is invoked.
        3.  The harness finds the SW's registered `onMessage` listener(s) and calls it/them.
    -   **SW to CS:**
        1.  Test triggers a condition in the imported `src/service-worker/index.ts` that leads to it calling `chrome.runtime.sendMessage` (or `chrome.tabs.sendMessage` if applicable, which the harness would also mock).
        2.  The harness's `sendMessage` (or `sendTabMessage`) mock is invoked.
        3.  The harness finds the CS's registered `onMessage` listener(s) and calls it/them.
    -   The harness will manage the flow, including the `sendResponse` mechanism.

3.4. **How to Verify Responses:**
    -   **Direct Return Values/Promises:** For CS functions that send a message and expect a Promise of a response, assert the resolved value of the Promise.
        ```typescript
        // In test:
        // const result = await contentScriptMessaging.getPrice();
        // expect(result).toEqual({ price: 50000 });
        ```
    -   **Listener Behavior:** For messages pushed from SW to CS, spy on or check the effects of the CS's listener being called (e.g., if it updates a (mocked) DOM element or calls another function).
    -   **Mocked Dependencies:** Verify interactions with other mocked external dependencies (e.g., `expect(fetch).toHaveBeenCalledWith(...)`, `expect(chrome.storage.local.get).toHaveBeenCalledWith(...)`).
    -   **`chrome.runtime.lastError`:** In error scenarios, check `harnessInstance.getMockChromeApi().runtime.lastError` for expected error messages.

### 4. Code Organization

4.1. **Test File Naming and Location:**
    -   Primary test file: `tests/integration/messaging.integration.test.ts`.
    -   Harness: `tests/harness/ChromeRuntimeHarness.ts`.
    -   Utilities/Mocks: `tests/utils/mockFetch.ts`, `tests/utils/mockStorage.ts`, etc.

4.2. **Test Suite Structure:**
    -   Use `describe` to group tests by functionality or message flow (e.g., "Content Script to Service Worker Communication", "Service Worker to Content Script Communication", "Error Handling").
    -   Use `it` or `test` for individual test cases with descriptive names.
    -   Employ `beforeEach` for setting up mocks and the harness, and `afterEach` for cleanup (e.g., `vi.restoreAllMocks()`, harness reset).

4.3. **Helper Functions Needed:**
    -   The `ChromeRuntimeHarness` class itself is the primary helper.
    -   Potentially, factory functions for creating common message payloads based on `src/common/types.ts`.
    -   Functions within tests to set up specific states for mocked `fetch` or `chrome.storage.local` to simulate cache hits/misses or API responses.

4.4. **Shared Test Utilities:**
    -   The `ChromeRuntimeHarness` is shared.
    -   Generic mock setups (e.g., a configurable `fetch` mock) can be placed in `tests/utils/`.

### 5. Technical Challenges

5.1. **Handling Async Messaging Patterns:**
    -   Utilize `async/await` thoroughly in tests and within the harness to manage asynchronous message passing and responses.
    -   Ensure `sendResponse` in the harness correctly handles the `return true` pattern to allow asynchronous responses from message listeners. Vitest's fake timers (`vi.useFakeTimers()`) might be useful if specific timeout behaviors related to `sendResponse` need to be tested.

5.2. **Simulating Service Worker Lifecycle:**
    -   For pure messaging tests, a full SW lifecycle simulation (install, activate, fetch events) is likely unnecessary. The focus is on the `onMessage` listeners being registered and active.
    -   The dynamic import and initialization of `src/service-worker/index.ts` in the test setup should be sufficient to register its message listeners with the harness.

5.3. **Testing Error Propagation:**
    -   The harness must accurately simulate how `chrome.runtime.lastError` is set when `sendMessage` fails (e.g., no listener) or when a listener's `sendResponse` indicates an error.
    -   Tests must explicitly check `chrome.runtime.lastError` in these scenarios.

5.4. **Ensuring Test Isolation:**
    -   Each test case must run independently.
    -   Use `beforeEach` to reset the harness's state (listeners, `lastError`) and any other global mocks (like `fetch` or `chrome.storage`).
    -   `vi.restoreAllMocks()` or `vi.resetAllMocks()` in `afterEach` is crucial.

### 6. Success Metrics

6.1. **Coverage Targets:**
    -   Achieve >80% line and branch coverage for the message handling logic in `src/service-worker/index.ts` and `src/content-script/messaging.ts`. This will be verified using Vitest's coverage reporting.

6.2. **Test Execution Time Considerations:**
    -   Tests should execute quickly to provide fast feedback. Aim for the entire integration suite to complete within a few seconds. Long-running tests indicate potential inefficiencies in the harness or test setup.

6.3. **Maintainability Factors:**
    -   The `ChromeRuntimeHarness` should be well-documented and easy to extend if new Chrome APIs are used for communication.
    -   Test cases should be clear, concise, and focused on a single scenario to ease understanding and future modifications.
    -   Adherence to DRY principles for common setup and assertion patterns.

6.4. **Documentation Requirements:**
    -   The tests themselves, with descriptive names and clear structure, will serve as primary documentation for the messaging protocol.
    -   TSDoc comments for the `ChromeRuntimeHarness` methods and complex test setups will explain the "why."
    -   No separate, redundant documentation documents are required; the code and its tests are the source of truth.